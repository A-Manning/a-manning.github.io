<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Ash Manning's Blog - Generalizing Biapplicatives</title>
        <link rel="stylesheet" href="../../css/default.css" />
        <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../../">Ash Manning</a>
            </div>
            <nav>
                <a href="../../">Home</a>
                <a href="../../about">About</a>
                <a href="../../contact">Contact</a>
                <a href="../../archive">Archive</a>
            </nav>
        </header>

        <main role="main">
            <!--  <h1>Generalizing Biapplicatives</h1> -->
            <article>
    <section class="header">
        Posted on August 12, 2020
        
    </section>
    <section>
        <h2 id="preliminaries">Preliminaries</h2>
<p>Applicative functors are pervasive in functional programming. Lists, options, effects, and a myriad others.</p>
<p>The definition of an applicative functor (in Haskell) is worth reviewing.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="ot">  pure ::</span> a <span class="ot">-&gt;</span> f a</span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="ot">  (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>Why are <code>pure</code> and <code>(&lt;*&gt;)</code> bundled together like this? Surely we could define a hierarchy, as with <code>Semigroup</code> and <code>Monoid</code>?</p>
<p>The difference here is that we need <code>pure</code>, in order to define meaningful laws for <code>(&lt;*&gt;)</code>.</p>
<p>The applicative laws are as follows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">-- Identity law</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="fu">pure</span> <span class="fu">id</span> <span class="op">&lt;*&gt;</span> v <span class="ot">=</span> v</span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co">-- Homomorphism law</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="fu">pure</span> f <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> x <span class="ot">=</span> <span class="fu">pure</span> (f x)</span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="co">-- Interchange law</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>u <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> y <span class="ot">=</span> <span class="fu">pure</span> (<span class="op">$</span> y) <span class="op">&lt;*&gt;</span> u</span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="co">-- Composition law</span></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="fu">pure</span> (<span class="op">.</span>) <span class="op">&lt;*&gt;</span> u <span class="op">&lt;*&gt;</span> v <span class="op">&lt;*&gt;</span> w <span class="ot">=</span> u <span class="op">&lt;*&gt;</span> (v <span class="op">&lt;*&gt;</span> w)</span></code></pre></div>
<h2 id="biapplicative-functors">Biapplicative functors</h2>
<p>With that in mind, let’s take a look at “biapplicative” functors. Not so different!</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">class</span> <span class="dt">Bifunctor</span> p <span class="ot">=&gt;</span> <span class="dt">Biapplicative</span> p <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="ot">  bipure ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> p a b</span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="ot">  (&lt;&lt;*&gt;&gt;) ::</span> p (a <span class="ot">-&gt;</span> b) (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> p a c <span class="ot">-&gt;</span> p b d</span></code></pre></div>
<p>Biapplicative functors are a generalization of applicative functors that support two type parameters, instead of one. Tuples are a familiar example of a type supporting a definition of <code>Biapplicative</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">instance</span> <span class="dt">Biapplicative</span> (,) <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a>  bipure <span class="ot">=</span> (,)</span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a>  (f, g) <span class="op">&lt;&lt;*&gt;&gt;</span> (a, b) <span class="ot">=</span> (f a, g b)</span></code></pre></div>
<p>What might be surprising is that it is <em>not</em> possible to define an instance of <code>Biapplicative</code> for <code>Either</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">instance</span> <span class="dt">Biapplicative</span> <span class="dt">Either</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="co">-- We could try this with `Right` instead;</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>  <span class="co">-- Since `Either` is symmetric, there is no difference.</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>  bipure <span class="ot">=</span> <span class="dt">Left</span> <span class="op">.</span> <span class="fu">const</span></span>
<span id="cb5-5"><a href="#cb5-5"></a></span>
<span id="cb5-6"><a href="#cb5-6"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">Left</span> f) (<span class="dt">Left</span> x) <span class="ot">=</span> <span class="dt">Left</span> (f x)</span>
<span id="cb5-7"><a href="#cb5-7"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">Right</span> g) (<span class="dt">Right</span> y) <span class="ot">=</span> <span class="dt">Right</span> (g y)</span>
<span id="cb5-8"><a href="#cb5-8"></a>  <span class="co">-- There is no way to define these cases</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">Left</span> f) (<span class="dt">Right</span> y) <span class="ot">=</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">Right</span> g) (<span class="dt">Left</span> x) <span class="ot">=</span></span></code></pre></div>
<p>We can, however, define <code>(&lt;&lt;*&gt;&gt;)</code> on <code>Maybe (Either a b)</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a>(<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">Just</span> (<span class="dt">Left</span> f)) (<span class="dt">Just</span> (<span class="dt">Left</span> x)) <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Left</span> (f x))</span>
<span id="cb6-2"><a href="#cb6-2"></a>(<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">Just</span> (<span class="dt">Left</span> _)) _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>(<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">Just</span> (<span class="dt">Right</span> g)) (<span class="dt">Just</span> (<span class="dt">Right</span> y)) <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Right</span> (g y))</span>
<span id="cb6-4"><a href="#cb6-4"></a>(<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">Just</span> (<span class="dt">Right</span> _)) _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>(<span class="op">&lt;&lt;*&gt;&gt;</span>) <span class="dt">Nothing</span> _ <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>What should we choose for <code>bipure</code>? All of the following seem reasonable:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a>bipure <span class="ot">=</span> <span class="dt">Left</span> <span class="op">.</span> <span class="fu">const</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>bipure <span class="ot">=</span> <span class="dt">Right</span> <span class="op">.</span> <span class="fu">const</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>bipure <span class="ot">=</span> <span class="fu">const</span> (<span class="fu">const</span> <span class="dt">Nothing</span>)</span></code></pre></div>
<p>At this point, it’s worth looking into the “Biapplicative laws”, which will tell us if we can define an instance <code>Biapplicative Maybe (Either a b)</code>, and perhaps resolve the choice of <code>bipure</code>. The biapplicative laws are fairly intuitive - they are almost the same as the applicative laws.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">-- Identity law</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>bipure <span class="fu">id</span> <span class="fu">id</span> <span class="op">&lt;&lt;*&gt;&gt;</span> v <span class="ot">=</span> v</span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="co">-- Homomorphism law</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>bipure f g <span class="op">&lt;&lt;*&gt;&gt;</span> bipure x y <span class="ot">=</span> bipure (f x) (g y)</span>
<span id="cb8-6"><a href="#cb8-6"></a></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="co">-- Interchange law</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>u <span class="op">&lt;&lt;*&gt;&gt;</span> bipure x y <span class="ot">=</span> bipure (<span class="op">$</span> x) (<span class="op">$</span> y) <span class="op">&lt;&lt;*&gt;&gt;</span> u</span>
<span id="cb8-9"><a href="#cb8-9"></a></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="co">-- Composition law</span></span>
<span id="cb8-11"><a href="#cb8-11"></a>bipure (<span class="op">.</span>) (<span class="op">.</span>) <span class="op">&lt;&lt;*&gt;&gt;</span> u <span class="op">&lt;&lt;*&gt;&gt;</span> v <span class="op">&lt;&lt;*&gt;&gt;</span> w <span class="ot">=</span> u <span class="op">&lt;&lt;*&gt;&gt;</span> (v <span class="op">&lt;&lt;*&gt;&gt;</span> w)</span></code></pre></div>
<p>At this point we can clearly see that no choice of <code>bipure</code> will satisfy the identity law or composition laws for <code>Maybe (Either a b)</code>.</p>
<h2 id="generalizing-biapplicative-functors">Generalizing Biapplicative Functors</h2>
<p>The definition of <code>Applicative</code> includes <code>pure</code> so that we can state the applicative laws. For the same reason, the definition of <code>Biapplicative</code> includes <code>bipure</code>. But does it have to? What if we were to rethink <code>Biapplicative</code>, with an alternative to <code>bipure</code>?</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">class</span> <span class="dt">Bifunctor</span> p <span class="ot">=&gt;</span> <span class="dt">Biapplicative</span> p <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2"></a></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="ot">  pureL ::</span> a <span class="ot">-&gt;</span> p a b</span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="ot">  pureR ::</span> b <span class="ot">-&gt;</span> p a b</span>
<span id="cb9-5"><a href="#cb9-5"></a></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="ot">  (&lt;&lt;*&gt;&gt;) ::</span> p (a <span class="ot">-&gt;</span> b) (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> p a c <span class="ot">-&gt;</span> p b d</span></code></pre></div>
<p>This definition is much nicer to work with; The instance for <code>Maybe (Either a b)</code> is much as it was before:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">instance</span> <span class="dt">Biapplicative</span> <span class="dt">Maybe</span> (<span class="dt">Either</span> a b) <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a>  pureL <span class="ot">=</span> <span class="dt">Just</span> <span class="op">.</span> <span class="dt">Left</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>  pureR <span class="ot">=</span> <span class="dt">Just</span> <span class="op">.</span> <span class="dt">Right</span></span>
<span id="cb10-5"><a href="#cb10-5"></a></span>
<span id="cb10-6"><a href="#cb10-6"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">Just</span> (<span class="dt">Left</span> f)) (<span class="dt">Just</span> (<span class="dt">Left</span> x))   <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Left</span> (f x))</span>
<span id="cb10-7"><a href="#cb10-7"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">Just</span> (<span class="dt">Left</span> _)) _                 <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb10-8"><a href="#cb10-8"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">Just</span> (<span class="dt">Right</span> g)) (<span class="dt">Just</span> (<span class="dt">Right</span> y)) <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Right</span> (g y))</span>
<span id="cb10-9"><a href="#cb10-9"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">Just</span> (<span class="dt">Right</span> _)) _                <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb10-10"><a href="#cb10-10"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) <span class="dt">Nothing</span> _                         <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>What about the laws for this definition? Since we have a left and right version of <code>pure</code> now, there are a few more laws:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="co">-- Identity laws</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>pureL <span class="fu">id</span> <span class="op">&lt;&lt;*&gt;&gt;</span> v <span class="ot">=</span> v</span>
<span id="cb11-3"><a href="#cb11-3"></a>pureR <span class="fu">id</span> <span class="op">&lt;&lt;*&gt;&gt;</span> v <span class="ot">=</span> v</span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="co">-- Homomorphism laws</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>pureL f <span class="op">&lt;&lt;*&gt;&gt;</span> pureL x <span class="ot">=</span> pureL (f x)</span>
<span id="cb11-7"><a href="#cb11-7"></a>pureR g <span class="op">&lt;&lt;*&gt;&gt;</span> pureR y <span class="ot">=</span> pureR (g y)</span>
<span id="cb11-8"><a href="#cb11-8"></a></span>
<span id="cb11-9"><a href="#cb11-9"></a><span class="co">-- Interchange laws</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>u <span class="op">&lt;&lt;*&gt;&gt;</span> pureL x <span class="ot">=</span> pureL (<span class="op">$</span> x) <span class="op">&lt;&lt;*&gt;&gt;</span> u</span>
<span id="cb11-11"><a href="#cb11-11"></a>u <span class="op">&lt;&lt;*&gt;&gt;</span> pureR y <span class="ot">=</span> pureR (<span class="op">$</span> y) <span class="op">&lt;&lt;*&gt;&gt;</span> u</span>
<span id="cb11-12"><a href="#cb11-12"></a></span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="co">-- Composition laws</span></span>
<span id="cb11-14"><a href="#cb11-14"></a>pureL (<span class="op">.</span>) <span class="op">&lt;&lt;*&gt;&gt;</span> u <span class="op">&lt;&lt;*&gt;&gt;</span> v <span class="op">&lt;&lt;*&gt;&gt;</span> w <span class="ot">=</span> u <span class="op">&lt;&lt;*&gt;&gt;</span> (v <span class="op">&lt;&lt;*&gt;&gt;</span> w)</span>
<span id="cb11-15"><a href="#cb11-15"></a>pureR (<span class="op">.</span>) <span class="op">&lt;&lt;*&gt;&gt;</span> u <span class="op">&lt;&lt;*&gt;&gt;</span> v <span class="op">&lt;&lt;*&gt;&gt;</span> w <span class="ot">=</span> u <span class="op">&lt;&lt;*&gt;&gt;</span> (v <span class="op">&lt;&lt;*&gt;&gt;</span> w)</span></code></pre></div>
<p>Unfortunately our instance still won’t satisfy the identity laws. What we really need is two versions of <code>(&lt;&lt;*&gt;&gt;)</code>, in the same vein as how <code>Bifunctor</code> has two versions of <code>Functor</code>’s <code>&lt;$&gt;</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">class</span> <span class="dt">Bifunctor</span> p <span class="ot">=&gt;</span> <span class="dt">Biapplicative</span> p <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="ot">  pureL ::</span> a <span class="ot">-&gt;</span> p a b</span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="ot">  pureR ::</span> b <span class="ot">-&gt;</span> p a b</span>
<span id="cb12-5"><a href="#cb12-5"></a></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="ot">  applyL ::</span> p (a <span class="ot">-&gt;</span> b) (c <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> p a c <span class="ot">-&gt;</span> p b c</span>
<span id="cb12-7"><a href="#cb12-7"></a>  applyL <span class="ot">=</span> (<span class="op">&lt;&lt;*&gt;&gt;</span>)</span>
<span id="cb12-8"><a href="#cb12-8"></a></span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="ot">  applyR ::</span> p (a <span class="ot">-&gt;</span> a) (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p a c</span>
<span id="cb12-10"><a href="#cb12-10"></a>  applyR <span class="ot">=</span> (<span class="op">&lt;&lt;*&gt;&gt;</span>)</span>
<span id="cb12-11"><a href="#cb12-11"></a></span>
<span id="cb12-12"><a href="#cb12-12"></a><span class="ot">  (&lt;&lt;*&gt;&gt;) ::</span> p (a <span class="ot">-&gt;</span> b) (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> p a c <span class="ot">-&gt;</span> p b d</span>
<span id="cb12-13"><a href="#cb12-13"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) p <span class="ot">=</span> (first (<span class="fu">const</span> <span class="fu">id</span>) p <span class="ot">`applyR`</span>) <span class="op">.</span> (second (<span class="fu">const</span> <span class="fu">id</span>) p <span class="ot">`applyL`</span>)</span></code></pre></div>
<p>Now we can write some more laws:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="co">-- Identity laws</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>pureL <span class="fu">id</span> <span class="ot">`applyL`</span> v <span class="ot">=</span> v</span>
<span id="cb13-3"><a href="#cb13-3"></a>pureR <span class="fu">id</span> <span class="ot">`applyR`</span> v <span class="ot">=</span> v</span>
<span id="cb13-4"><a href="#cb13-4"></a></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="co">-- Homomorphism laws</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>pureL f <span class="ot">`applyL`</span> pureL x <span class="ot">=</span> pureL (f x)</span>
<span id="cb13-7"><a href="#cb13-7"></a>pureR g <span class="ot">`applyL`</span> pureR y <span class="ot">=</span> pureR (g y)</span>
<span id="cb13-8"><a href="#cb13-8"></a>pureL f <span class="ot">`applyR`</span> pureL x <span class="ot">=</span> pureL (f x)</span>
<span id="cb13-9"><a href="#cb13-9"></a>pureR g <span class="ot">`applyR`</span> pureR y <span class="ot">=</span> pureR (g y)</span>
<span id="cb13-10"><a href="#cb13-10"></a></span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="co">-- Interchange laws</span></span>
<span id="cb13-12"><a href="#cb13-12"></a>u <span class="op">&lt;&lt;*&gt;&gt;</span> pureL x <span class="ot">=</span> pureL (<span class="op">$</span> x) <span class="op">&lt;&lt;*&gt;&gt;</span> u</span>
<span id="cb13-13"><a href="#cb13-13"></a>u <span class="op">&lt;&lt;*&gt;&gt;</span> pureR y <span class="ot">=</span> pureR (<span class="op">$</span> y) <span class="op">&lt;&lt;*&gt;&gt;</span> u</span>
<span id="cb13-14"><a href="#cb13-14"></a></span>
<span id="cb13-15"><a href="#cb13-15"></a><span class="co">-- Composition laws</span></span>
<span id="cb13-16"><a href="#cb13-16"></a>pureL (<span class="op">.</span>) <span class="op">&lt;&lt;*&gt;&gt;</span> u <span class="op">&lt;&lt;*&gt;&gt;</span> v <span class="op">&lt;&lt;*&gt;&gt;</span> w <span class="ot">=</span> u <span class="op">&lt;&lt;*&gt;&gt;</span> (v <span class="op">&lt;&lt;*&gt;&gt;</span> w)</span>
<span id="cb13-17"><a href="#cb13-17"></a>pureR (<span class="op">.</span>) <span class="op">&lt;&lt;*&gt;&gt;</span> u <span class="op">&lt;&lt;*&gt;&gt;</span> v <span class="op">&lt;&lt;*&gt;&gt;</span> w <span class="ot">=</span> u <span class="op">&lt;&lt;*&gt;&gt;</span> (v <span class="op">&lt;&lt;*&gt;&gt;</span> w)</span></code></pre></div>
<p>These laws are effectively the applicative functor laws but mirrored for each “side” of our biapplicative.</p>
<p>Finally, we can write a <em>lawful</em> instance!</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">instance</span> <span class="dt">Biapplicative</span> <span class="dt">Maybe</span> (<span class="dt">Either</span> a b) <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>  pureL <span class="ot">=</span> <span class="dt">Just</span> <span class="op">.</span> <span class="dt">Left</span></span>
<span id="cb14-3"><a href="#cb14-3"></a>  pureR <span class="ot">=</span> <span class="dt">Just</span> <span class="op">.</span> <span class="dt">Right</span></span>
<span id="cb14-4"><a href="#cb14-4"></a></span>
<span id="cb14-5"><a href="#cb14-5"></a>  applyL (<span class="dt">Just</span> (<span class="dt">Left</span> f)) (<span class="dt">Just</span> (<span class="dt">Left</span> x))   <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Left</span> (f x))</span>
<span id="cb14-6"><a href="#cb14-6"></a>  applyL (<span class="dt">Just</span> (<span class="dt">Left</span> _)) (<span class="dt">Just</span> (<span class="dt">Right</span> y))  <span class="ot">=</span> pureR y</span>
<span id="cb14-7"><a href="#cb14-7"></a>  applyL (<span class="dt">Just</span> (<span class="dt">Left</span> _)) <span class="dt">Nothing</span>           <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>  applyL (<span class="dt">Just</span> (<span class="dt">Right</span> g)) (<span class="dt">Just</span> (<span class="dt">Right</span> y)) <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Right</span> (g y))</span>
<span id="cb14-9"><a href="#cb14-9"></a>  applyL (<span class="dt">Just</span> (<span class="dt">Right</span> _)) _                <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>  applyL <span class="dt">Nothing</span> _                         <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb14-11"><a href="#cb14-11"></a></span>
<span id="cb14-12"><a href="#cb14-12"></a>  applyR (<span class="dt">Just</span> (<span class="dt">Right</span> g)) (<span class="dt">Just</span> (<span class="dt">Right</span> y)) <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Right</span> (g y))</span>
<span id="cb14-13"><a href="#cb14-13"></a>  applyR (<span class="dt">Just</span> (<span class="dt">Right</span> _)) (<span class="dt">Just</span> (<span class="dt">Left</span> x))  <span class="ot">=</span> pureL x</span>
<span id="cb14-14"><a href="#cb14-14"></a>  applyR (<span class="dt">Just</span> (<span class="dt">Right</span> _)) <span class="dt">Nothing</span>          <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb14-15"><a href="#cb14-15"></a>  applyR (<span class="dt">Just</span> (<span class="dt">Left</span> f)) (<span class="dt">Just</span> (<span class="dt">Left</span> x))   <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Left</span> (f x))</span>
<span id="cb14-16"><a href="#cb14-16"></a>  applyR (<span class="dt">Just</span> (<span class="dt">Left</span> _)) _                 <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb14-17"><a href="#cb14-17"></a>  applyR <span class="dt">Nothing</span> _                         <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>There’s still a problem. Because we’ve replaced <code>bipure</code> with <code>pureL</code> and <code>pureR</code>, we can no longer define an instance of <code>Biapplicative (,)</code>.</p>
<p>I think that this is sufficiently motivating to split our <code>Biapplicative</code> definition into three parts.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">class</span> <span class="dt">Bifunctor</span> p <span class="ot">=&gt;</span> <span class="dt">Biapplicative</span> p <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2"></a></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="ot">  applyL ::</span> p (a <span class="ot">-&gt;</span> b) (c <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> p a c <span class="ot">-&gt;</span> p b c</span>
<span id="cb15-4"><a href="#cb15-4"></a>  applyL <span class="ot">=</span> (<span class="op">&lt;&lt;*&gt;&gt;</span>)</span>
<span id="cb15-5"><a href="#cb15-5"></a></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="ot">  applyR ::</span> p (a <span class="ot">-&gt;</span> a) (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p a c</span>
<span id="cb15-7"><a href="#cb15-7"></a>  applyR <span class="ot">=</span> (<span class="op">&lt;&lt;*&gt;&gt;</span>)</span>
<span id="cb15-8"><a href="#cb15-8"></a></span>
<span id="cb15-9"><a href="#cb15-9"></a><span class="ot">  (&lt;&lt;*&gt;&gt;) ::</span> p (a <span class="ot">-&gt;</span> b) (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> p a c <span class="ot">-&gt;</span> p b d</span>
<span id="cb15-10"><a href="#cb15-10"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) p <span class="ot">=</span> (first (<span class="fu">const</span> <span class="fu">id</span>) p <span class="ot">`applyR`</span>) <span class="op">.</span> (second (<span class="fu">const</span> <span class="fu">id</span>) p <span class="ot">`applyL`</span>)</span>
<span id="cb15-11"><a href="#cb15-11"></a></span>
<span id="cb15-12"><a href="#cb15-12"></a><span class="kw">class</span> <span class="dt">Biapplicative</span> p <span class="ot">=&gt;</span> <span class="dt">Biapplicative1</span> p <span class="kw">where</span></span>
<span id="cb15-13"><a href="#cb15-13"></a><span class="ot">  pureL ::</span> a <span class="ot">-&gt;</span> p a b</span>
<span id="cb15-14"><a href="#cb15-14"></a><span class="ot">  pureR ::</span> b <span class="ot">-&gt;</span> p a b</span>
<span id="cb15-15"><a href="#cb15-15"></a></span>
<span id="cb15-16"><a href="#cb15-16"></a><span class="kw">class</span> <span class="dt">Biapplicative</span> p <span class="ot">=&gt;</span> <span class="dt">Biapplicative2</span> p <span class="kw">where</span></span>
<span id="cb15-17"><a href="#cb15-17"></a><span class="ot">  bipure ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> p a b</span></code></pre></div>
<p>The laws for <code>Biapplicative1</code> and <code>Biapplicative2</code> are as we saw above, using <code>pureL</code> and <code>pureR</code> to describe the <code>Biapplicative1</code> laws, and <code>bipure</code> to describe the <code>Biapplicative2</code> laws.</p>
<p>Indeed, it is possible for a biapplicative functor to have instances of both <code>Biapplicative1</code> and <code>Biapplicative2</code>.</p>
<p>One such example is given below:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">data</span> <span class="dt">EitherBothNothing</span> a b <span class="ot">=</span> <span class="dt">B</span> a b <span class="op">|</span> <span class="dt">L</span> a <span class="op">|</span> <span class="dt">R</span> b <span class="op">|</span> <span class="dt">N</span></span>
<span id="cb16-2"><a href="#cb16-2"></a></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="kw">instance</span> <span class="dt">Bifunctor</span> <span class="dt">EitherBothNothing</span> <span class="kw">where</span></span>
<span id="cb16-4"><a href="#cb16-4"></a></span>
<span id="cb16-5"><a href="#cb16-5"></a>  bimap f g <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb16-6"><a href="#cb16-6"></a>    <span class="dt">B</span> x y <span class="ot">-&gt;</span> <span class="dt">B</span> (f x) (g y)</span>
<span id="cb16-7"><a href="#cb16-7"></a>    <span class="dt">L</span> x <span class="ot">-&gt;</span> <span class="dt">L</span> (f x)</span>
<span id="cb16-8"><a href="#cb16-8"></a>    <span class="dt">R</span> y <span class="ot">-&gt;</span> <span class="dt">R</span> (g y)</span>
<span id="cb16-9"><a href="#cb16-9"></a>    <span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">N</span></span>
<span id="cb16-10"><a href="#cb16-10"></a></span>
<span id="cb16-11"><a href="#cb16-11"></a><span class="kw">instance</span> <span class="dt">Biapplicative</span> <span class="dt">EitherBothNothing</span> <span class="kw">where</span></span>
<span id="cb16-12"><a href="#cb16-12"></a></span>
<span id="cb16-13"><a href="#cb16-13"></a>  applyL (<span class="dt">B</span> f g) (<span class="dt">B</span> x y) <span class="ot">=</span> <span class="dt">B</span> (f x) (g y)</span>
<span id="cb16-14"><a href="#cb16-14"></a>  applyL (<span class="dt">B</span> f _) (<span class="dt">L</span> x) <span class="ot">=</span> <span class="dt">L</span> (f x)</span>
<span id="cb16-15"><a href="#cb16-15"></a>  applyL (<span class="dt">B</span> _ g) (<span class="dt">R</span> y) <span class="ot">=</span> <span class="dt">R</span> (g y)</span>
<span id="cb16-16"><a href="#cb16-16"></a>  applyL (<span class="dt">L</span> f) (<span class="dt">B</span> x y) <span class="ot">=</span> <span class="dt">B</span> (f x) y</span>
<span id="cb16-17"><a href="#cb16-17"></a>  applyL (<span class="dt">L</span> f) (<span class="dt">L</span> x) <span class="ot">=</span> <span class="dt">L</span> (f x)</span>
<span id="cb16-18"><a href="#cb16-18"></a>  applyL (<span class="dt">L</span> _) (<span class="dt">R</span> y) <span class="ot">=</span> <span class="dt">R</span> y</span>
<span id="cb16-19"><a href="#cb16-19"></a>  applyL (<span class="dt">R</span> g) (<span class="dt">B</span> _ y) <span class="ot">=</span> <span class="dt">R</span> (g y)</span>
<span id="cb16-20"><a href="#cb16-20"></a>  applyL (<span class="dt">R</span> _) (<span class="dt">L</span> x) <span class="ot">=</span> <span class="dt">N</span></span>
<span id="cb16-21"><a href="#cb16-21"></a>  applyL (<span class="dt">R</span> g) (<span class="dt">R</span> y) <span class="ot">=</span> <span class="dt">R</span> (g y)</span>
<span id="cb16-22"><a href="#cb16-22"></a>  applyL <span class="dt">N</span> _ <span class="ot">=</span> <span class="dt">N</span></span>
<span id="cb16-23"><a href="#cb16-23"></a>  applyL _ <span class="dt">N</span> <span class="ot">=</span> <span class="dt">N</span></span>
<span id="cb16-24"><a href="#cb16-24"></a></span>
<span id="cb16-25"><a href="#cb16-25"></a>  applyR (<span class="dt">B</span> f g) (<span class="dt">B</span> x y) <span class="ot">=</span> <span class="dt">B</span> (f x) (g y)</span>
<span id="cb16-26"><a href="#cb16-26"></a>  applyR (<span class="dt">B</span> f _) (<span class="dt">L</span> x) <span class="ot">=</span> <span class="dt">L</span> (f x)</span>
<span id="cb16-27"><a href="#cb16-27"></a>  applyR (<span class="dt">B</span> _ g) (<span class="dt">R</span> y) <span class="ot">=</span> <span class="dt">R</span> (g y)</span>
<span id="cb16-28"><a href="#cb16-28"></a>  applyR (<span class="dt">L</span> f) (<span class="dt">B</span> x _) <span class="ot">=</span> <span class="dt">L</span> (f x)</span>
<span id="cb16-29"><a href="#cb16-29"></a>  applyR (<span class="dt">L</span> f) (<span class="dt">L</span> x) <span class="ot">=</span> <span class="dt">L</span> (f x)</span>
<span id="cb16-30"><a href="#cb16-30"></a>  applyR (<span class="dt">L</span> _) (<span class="dt">R</span> _) <span class="ot">=</span> <span class="dt">N</span></span>
<span id="cb16-31"><a href="#cb16-31"></a>  applyR (<span class="dt">R</span> g) (<span class="dt">B</span> x y) <span class="ot">=</span> <span class="dt">B</span> x (g y)</span>
<span id="cb16-32"><a href="#cb16-32"></a>  applyR (<span class="dt">R</span> _) (<span class="dt">L</span> x) <span class="ot">=</span> <span class="dt">L</span> x</span>
<span id="cb16-33"><a href="#cb16-33"></a>  applyR (<span class="dt">R</span> g) (<span class="dt">R</span> y) <span class="ot">=</span> <span class="dt">R</span> (g y)</span>
<span id="cb16-34"><a href="#cb16-34"></a>  applyR <span class="dt">N</span> _ <span class="ot">=</span> <span class="dt">N</span></span>
<span id="cb16-35"><a href="#cb16-35"></a>  applyR _ <span class="dt">N</span> <span class="ot">=</span> <span class="dt">N</span></span>
<span id="cb16-36"><a href="#cb16-36"></a></span>
<span id="cb16-37"><a href="#cb16-37"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">B</span> f g) (<span class="dt">B</span> x y) <span class="ot">=</span> <span class="dt">B</span> (f x) (g y)</span>
<span id="cb16-38"><a href="#cb16-38"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">B</span> f _) (<span class="dt">L</span> x) <span class="ot">=</span> <span class="dt">L</span> (f x)</span>
<span id="cb16-39"><a href="#cb16-39"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">B</span> _ g) (<span class="dt">R</span> y) <span class="ot">=</span> <span class="dt">R</span> (g y)</span>
<span id="cb16-40"><a href="#cb16-40"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">L</span> f) (<span class="dt">B</span> x _) <span class="ot">=</span> <span class="dt">L</span> (f x)</span>
<span id="cb16-41"><a href="#cb16-41"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">L</span> f) (<span class="dt">L</span> x) <span class="ot">=</span> <span class="dt">L</span> (f x)</span>
<span id="cb16-42"><a href="#cb16-42"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">L</span> _) (<span class="dt">R</span> _) <span class="ot">=</span> <span class="dt">N</span></span>
<span id="cb16-43"><a href="#cb16-43"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">R</span> g) (<span class="dt">B</span> x y) <span class="ot">=</span> <span class="dt">R</span> (g y)</span>
<span id="cb16-44"><a href="#cb16-44"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">R</span> _) (<span class="dt">L</span> _) <span class="ot">=</span> <span class="dt">N</span></span>
<span id="cb16-45"><a href="#cb16-45"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) (<span class="dt">R</span> g) (<span class="dt">R</span> y) <span class="ot">=</span> <span class="dt">R</span> (g y)</span>
<span id="cb16-46"><a href="#cb16-46"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) <span class="dt">N</span> _ <span class="ot">=</span> <span class="dt">N</span></span>
<span id="cb16-47"><a href="#cb16-47"></a>  (<span class="op">&lt;&lt;*&gt;&gt;</span>) _ <span class="dt">N</span> <span class="ot">=</span> <span class="dt">N</span></span>
<span id="cb16-48"><a href="#cb16-48"></a></span>
<span id="cb16-49"><a href="#cb16-49"></a><span class="kw">instance</span> <span class="dt">Biapplicative1</span> <span class="dt">EitherBothNothing</span> <span class="kw">where</span></span>
<span id="cb16-50"><a href="#cb16-50"></a></span>
<span id="cb16-51"><a href="#cb16-51"></a>  pureL <span class="ot">=</span> <span class="dt">L</span></span>
<span id="cb16-52"><a href="#cb16-52"></a></span>
<span id="cb16-53"><a href="#cb16-53"></a>  pureR <span class="ot">=</span> <span class="dt">R</span></span>
<span id="cb16-54"><a href="#cb16-54"></a></span>
<span id="cb16-55"><a href="#cb16-55"></a><span class="kw">instance</span> <span class="dt">Biapplicative2</span> <span class="dt">EitherBothNothing</span> <span class="kw">where</span></span>
<span id="cb16-56"><a href="#cb16-56"></a></span>
<span id="cb16-57"><a href="#cb16-57"></a>  bipure <span class="ot">=</span> <span class="dt">B</span></span></code></pre></div>
    </section>
</article>

        </main>

        <footer>
            This site was generated with
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
        </footer>
    </body>
</html>
